<h1 id="교재">교재</h1>
<p>개발자를 위한 실전 선형대수학 - 마이크 X 코헨 저/장정호 역</p>
<h1 id="시작">시작</h1>
<p>2학년 전공을 듣다보니, 앞으로 있을 3학년 전공에 기계학습 내용이 두려워졌다. 이에 부족한 부분을 채울 방법을 알아보다, 선형대수로 갈피를 잡았다. 계획은 5주차 스터딘데 될 진 모르겠다.</p>
<h1 id="연습문제">연습문제</h1>
<p><a href="https://github.com/rawfiremeat/linearArgebra">깃허브 링크</a></p>
<h1 id="chapter-1">Chapter 1</h1>
<p>ch1 에서는 선형대수의 기본인 벡터에 대해 배운다.</p>
<h2 id="벡터">벡터</h2>
<p>벡터는 수를 순서대로 나열한 것임.
벡터에는 2가지 중요한 특성이 있음</p>
<ul>
<li>차원: 벡터가 가진 원소수</li>
<li>방향: 열 방향, 행방향 등을 나타내는</li>
</ul>
<p>차원은 R^2 등으로 나타낼 수 있음 원소가 두개라는 뜻임</p>
<p><img alt="" src="https://velog.velcdn.com/images/9409velog/post/75408f22-a212-4d8d-82fc-95111360d47e/image.png" /></p>
<p>X는 4차원 열벡터  Y는 2차원 열벡터, Z는 4차원 행벡터라고 할 수 있음.</p>
<blockquote>
<p>Numpy의 차원과 벡터의 차원은 다르다는 것을 알자
파이썬에서는 차원은 벡터의 len 이나 shape으로 나타냄</p>
</blockquote>
<pre><code class="language-python"># a vector as a Python list datatype
asList = [1,2,3]

# same numbers, but as a dimensionless numpy array
asArray = np.array([1,2,3])

# again same numbers, but now endowed with orientations
rowVec = np.array([ [1,2,3] ]) # row
colVec = np.array([ [1],[2],[3] ]) # column</code></pre>
<p>asArray는 shapedl (3,) 이다 방향이 없는 것이다. 행렬만 행렬이지, 리스트와 크게 다를 게 없다.
row와 col 벡터는 대괄호로 구분을 할 수 있다.</p>
<h2 id="벡터-연산">벡터 연산</h2>
<h3 id="덧셈과-뺄셈">덧셈과 뺄셈</h3>
<p>쉽게 대응되는 원소끼리 더하거나 빼면 된다. 다만 이때, 동일한 차원과 방향을 가지는 벡터끼리 연산이 이루어져야 원하는 결과를 얻을 수 있다.</p>
<p>실제로 파이썬에서는 </p>
<pre><code class="language-python">v = np.array([[4,5,6]])
w = np.array([[100,20,30]]).T

v + w</code></pre>
<p>의 결과는 </p>
<pre><code class="language-python">array([[104, 105, 106],
       [ 24,  25,  26],
       [ 34,  35,  36]])</code></pre>
<p>이다 브로드 캐스팅이 진행된 결과이다.</p>
<h3 id="벡터-덧셈과-뺄셈의-기하학적-해석">벡터 덧셈과 뺄셈의 기하학적 해석</h3>
<p><img alt="" src="https://velog.velcdn.com/images/9409velog/post/ba067b91-aa87-489b-b643-764e580131a7/image.png" /></p>
<p>뺄셈이 중요한데, 빼는 벡터의 머리에서 상대 벡터의 머리로 벡터를 그으면 된다. </p>
<h3 id="스칼라-벡터-곱셈-덧셈">스칼라-벡터 곱셈, 덧셈</h3>
<p>선형대수하다 많이 나오는 곱셈 형식이다. 방법은 간단하다. 각 벡터 원소에 스칼라를 곱하면 된다. numpy에서는 array 타입의 콜렉션에 수를 곱함으로서 스칼라 벡터 곱셈을 구현한다. (리스트에 곱하면 리스트 반복이므로 주의)</p>
<p>스칼라와 벡터를 더하는 것은 본디 선형대수에서 불가능 하다. 하지만 파이썬에서는 할 수 있으며, 각 원소에 스칼라값이 더해진다.</p>
<h3 id="스칼라-벡터-곱셈의-기하학적-해석">스칼라-벡터 곱셈의 기하학적 해석</h3>
<p>스칼라는 벡터의 방향을 바꾸지 않고 크기만 조정해줌. 즉 스칼라가 음수라 벡터의 방향이 뒤집혀도, 벡터의 부분공간으로 봤을 때는 방향이 바뀐것은 아님.</p>
<ul>
<li>벡터 평균: 벡터집합에 있는 벡터들을 모두 더하고 숫자의 개수로 나누면 된다.</li>
</ul>
<h2 id="전치">전치</h2>
<p>트랜스 포즈라고 한다. m.t(ij) = m(ji) 즉 행렬의 열 요소와 행 요소를 바꾼다고 생각하면 된다. 추가적으로 전치를 두번하면 원래 방향이 된다. 이는 꽤 중요한 개념이다.</p>
<h2 id="크기와-단위벡터">크기와 단위벡터</h2>
<p>벡터의 크기를 norm이라고 한다. 유클리드 거리 공식으로 구할 수 있고,
<img alt="" src="https://velog.velcdn.com/images/9409velog/post/8549b6e2-7e61-4fd0-8896-cd8c28f8d931/image.png" /></p>
<p>다음과 같이 식을 나타낼 수 있다.
파이썬에서는 넘파이 라이브러리에 linalg.norm(벡터) 로 구할 수 있다.</p>
<p>단위벡터는 크기가 1인 벡터이다. </p>
<h2 id="벡터-내적">벡터-내적</h2>
<p>내적은 중요한 연산이라고 할 수 있다. 일반적으로는 a.t * a 라고 표현 한다. 내적을 계산하려면 두 벡터에서 대응되는 원솎리 곱한 다음 모든 결과를 다하면 된다. 
numpy에서는 dot 이라는 메서드를 제공한다.
내적은 벡터 사이의 유사성에 대한 척도이다. 내적의 수학적 식은 사실 두 벡터의 크기 곱 과 두 벡터의 사이각의 코사인 과의 곱이다. 즉 사이각이 90에 가까울 수록 내적의 크기는 작아지고, 반면에 0이나 180에 가까울 수록 내적의 크기는 커진다. 내적의 제곱이나, 절댓값이 커지면 둘은 비슷한 벡터라고 생각하면 된다.</p>
<h2 id="직교-벡터-분해">직교 벡터 분해</h2>
<p>한 벡터를 직교하는 두 벡터로 분해하는 연산이다. '
그 전에 최소거리 투영, 직교 투영법에 대해 알고 있으면 좋은데, 
직교 투영법이란 쉽게 말해서 두벡터가 잇으면, 한 벡터의 한 점에서 나머지 벡터로 선을 그을 때 그 선의 길이가 최소가 되게 선을 긋는 방법인데, 당연하겠지만, 다른 벡터에 수직에 되도록 긋는게 맞다.
그 과정에서, 
<img alt="" src="https://velog.velcdn.com/images/9409velog/post/47581da7-7ae5-4a6f-a3e8-58541d2d97da/image.png" />
이런 식이 도출된다. 베타 a 가 선을 긋는 위치에서의 벡터 a의 크기를 다르게 한 것이라고 생각하면 된다. 둘이 직교기 때문에 내적이 0인 식으로 베타를 도출해 낼 수 있다. </p>
<p>본격적으로 직교 벡터 분해를 보자면, 목표벡터를 t, 기분벡터를 r이라고 두면, t를 하나는 r에 평행한, 하나는 수직인 벡터로 분해하는 것이라고 생각하면 된다. 즉 r에 평행한 벡터는 t에서 r로 직교 투영을 했을 때 r에 찍히는 점 까지의 벡터가 평행하고, 그에 수직인 벡터가 수직 벡터인 것이다.</p>